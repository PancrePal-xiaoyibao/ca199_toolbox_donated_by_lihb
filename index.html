<!--
  CA199 åŒ»ç–—æŒ‡æ ‡å¯è§†åŒ–å·¥å…·
  Copyright (C) 2025 lihb

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Affero General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
-->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>åŒ»ç–—æŒ‡æ ‡è¶‹åŠ¿ç®¡ç†ä¸€é¡µé€š</title>
  <script src="js/papaparse.min.js"></script>
  <script src="js/echarts.min.js"></script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background-color: #f9fafb;
      padding: 1.5rem;
      margin: 0;
    }
    h1 {
      font-size: 1.75rem;
      font-weight: 700;
      color: #7c3aed;
      margin: 0;
      letter-spacing: -0.025em;
    }
    .header-container {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-bottom: 0.75rem;
    }
    .logo {
      width: 3.5rem;
      height: auto;
      filter: drop-shadow(0 4px 6px rgba(124, 58, 237, 0.1));
    }
    .subtitle {
      font-size: 0.9375rem;
      color: #4b5563;
      margin-bottom: 2rem;
      line-height: 1.8;
    }
    .subtitle p {
      margin: 0.25rem 0;
    }
    .hidden { display: none; }
    .btn-file {
      padding: 0.375rem 0.75rem;
      background: #4f46e5;
      color: white;
      border: none;
      border-radius: 0.375rem;
      cursor: pointer;
      font-size: 0.875rem;
      margin-right: 0.5rem;
    }
    .btn-file:hover { background: #4338ca; }
    .file-info {
      font-size: 0.875rem;
      color: #4b5563;
      margin-top: 1.25rem;
    }
    .render-btn {
      margin-top: 0.75rem;
      width: 100%;
      background-color: #2563eb;
      color: white;
      padding: 0.375rem 0;
      border-radius: 0.375rem;
      font-size: 0.875rem;
      border: none;
      cursor: pointer;
    }
    .render-btn:hover { background-color: #1d4ed8; }
    .content-container {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    @media (min-width: 1024px) {
      .content-container { flex-direction: row; }
    }
    .chart-container, .timeline-container {
      height: 550px;
      width: 100%;
      background: white;
      border: 1px solid #e5e7eb;
      border-radius: 0.5rem;
    }
    .timeline-container { height: 150px; margin-top: 1rem; }
    .selector-panel, .control-panel {
      width: 14rem;
      background: white;
      padding: 0.5rem;
      border: 1px solid #e5e7eb;
      border-radius: 0.5rem;
      font-size: 0.875rem;
      max-height: 650px;
      overflow-y: auto;
    }
    @media (min-width: 1024px) {
      .selector-panel, .control-panel { width: 12rem; flex-shrink: 0; }
    }
    .checkbox-item {
      display: flex;
      align-items: center;
      padding: 0.25rem 0.5rem;
      border: 1px solid #e5e7eb;
      border-radius: 0.375rem;
      cursor: pointer;
      font-size: 0.875rem;
    }
    .checkbox-item:hover { background-color: #f9fafb; }
    .checkbox-item input { margin-right: 0.5rem; }
    .legend-container {
      margin-top: 0.5rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .legend-item { display: flex; align-items: center; font-size: 0.75rem; }
    .legend-color { width: 12px; height: 12px; border-radius: 2px; margin-right: 0.3rem; }

    .control-panel label {
      font-size: 0.875rem;
    }
    .control-panel input[type="checkbox"] {
      transform: scale(1.2);
    }
    .control-panel input[type="number"],
    .control-panel input[type="range"] {
      margin-top: 0.25rem;
    }

    .rich-text {
      font-size: 12px !important;
      font-weight: bold;
      color: #FF6B6B;
    }
    .w-full { width: 100%; box-sizing: border-box; }
    .px-2 { padding-left: 0.5rem; padding-right: 0.5rem; }
    .py-1 { padding-top: 0.25rem; padding-bottom: 0.25rem; }
    .border { border: 1px solid #e5e7eb; }
    .rounded { border-radius: 0.25rem; }
    .text-sm { font-size: 0.875rem; }
    .mb-2 { margin-bottom: 0.5rem; }
  </style>
</head>
<body>
  <div class="header-container">
    <img src="https://picgo-1302991947.cos.ap-guangzhou.myqcloud.com/images/Pop%20Mart%20Character%20Front%20View%20(2).png" alt="Logo" class="logo">
    <h1>åŒ»ç–—æŒ‡æ ‡è¶‹åŠ¿ç®¡ç†ä¸€é¡µé€š</h1>
  </div>
  <div class="subtitle">
    <p>â¡ï¸ æœ¬é¡¹ç›®æ„Ÿè°¢æ°å‡ºå¿—æ„¿è€…@lihbçš„ä»£ç è´¡çŒ®å’Œæ— ç§å¼€æºï¼Œæºæ‰‹å°xå®ç¤¾åŒºï¼Œç”¨â¤ï¸å‘ç”µï¼ŒåŠ©åŠ›è‚¿ç˜¤æ‚£è€…ä¸»åŠ¨ç§‘å­¦ç—…æƒ…ç®¡ç†ã€‚è¯·å…³æ³¨å¾®ä¿¡å…¬ä¼—å·â€œå°èƒ°å®åŠ©æ‰‹â€ã€‚</p>
    <p>â¡ï¸ å°èƒ°å®ç¤¾åŒºï¼Œæ˜¯é‡åº†å¤©å·¥å¼€ç‰©åŸºé‡‘ä¼šæ——ä¸‹ï¼Œä¸“æ³¨æ”¯æŒèƒ°è…ºè‚¿ç˜¤æ‚£è€…/å®¶åº­ç—…æƒ…ä¸»åŠ¨ç®¡ç†çš„AIæŠ€æœ¯å¼€æºå…¬ç›Šç¤¾åŒºã€‚</p>
  </div>
  <div style="margin-bottom: 1.5rem; display: flex; gap: 1rem; flex-wrap: wrap;">
    <div>
      <label class="btn-file" title="è¯·é€‰æ‹©åŒç›®å½•ä¸‹çš„ data.csv">
        åŠ è½½æŒ‡æ ‡æ•°æ® (data.csv)
        <input type="file" id="dataFile" accept=".csv" style="display:none" />
      </label>
      <div id="dataFileName" class="file-info"></div>
    </div>

    <div>
      <label class="btn-file" title="è¯·é€‰æ‹©åŒç›®å½•ä¸‹çš„ medication.csv">
        åŠ è½½ç”¨è¯æ•°æ® (medication.csv)
        <input type="file" id="medFile" accept=".csv" style="display:none" />
      </label>
      <div id="medFileName" class="file-info"></div>
    </div>
  </div>

  <div id="content" class="hidden">
    <div class="content-container">
      <div style="flex:1; min-width:0;">
        <div id="chartContainer" class="chart-container"></div>
        <div id="timelineContainer" class="timeline-container"></div>
        <div id="legendContainer" class="legend-container"></div>
      </div>
      <div class="selector-panel">
        <div class="control-title" style="font-weight:600;margin-bottom:0.5rem;">æ˜¾ç¤ºæ§åˆ¶</div>

        <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 0.5rem;">
          <label style="margin-right: 0.5rem;">å…³é”®ç‚¹</label>
          <input type="checkbox" id="showKeyPoints" checked />
          <label style="margin-right: 0.5rem;">å˜åŒ–ç‡</label>
          <input type="checkbox" id="showChangeRate" />
        </div>



        <div id="changeThresholdContainer" style="display: none; margin-top: 0.5rem;">
          <label style="display: block; font-size: 0.75rem; color: #4b5563; margin-bottom: 0.25rem;">æ•°å€¼å˜åŒ– â‰¥</label>
          <input type="number" id="changeThreshold" value="0" min="0" step="0.1" style="width: 95%; padding: 0.375rem; border: 1px solid #d1d5db; border-radius: 0.375rem; font-size: 0.875rem;" />
        </div>

        <div id="percentThresholdContainer" style="display: none; margin-top: 0.5rem;">
          <label style="display: block; font-size: 0.75rem; color: #4b5563; margin-bottom: 0.25rem;">å˜åŒ–å¹…åº¦ â‰¥ <span id="percentValue">20%</span></label>
          <input type="range" id="percentThreshold" min="0" max="100" value="20" style="width: 100%;" />
        </div>

        <div class="selector-title" style="font-weight:600;margin-bottom:0.5rem;">é€‰æ‹©æŒ‡æ ‡</div>
          <div class="mb-2">
            <input
              type="text"
              placeholder="æœç´¢æŒ‡æ ‡..."
              class="w-full px-2 py-1 border rounded text-sm"
              id="indicatorSearchInput"
              oninput="filterIndicators()"
            >
          </div>
        <div id="checkboxContainer"></div>
        <button onclick="renderCharts()" class="render-btn">ç”Ÿæˆå›¾è¡¨</button>
      </div>
    </div>
  </div>

<script>
let allIndicators = [];
let medications = [];
let uniqueNames = [];

const DEFAULT_CONFIG = {
  dataTable: {
    timeField: 'testTime',
    nameField: 'indicatorName',
    valueField: 'indicatorValue'
  },
  medicationTable: {
    startTimeField: 'START_DATE',
    endTimeField: 'END_DATE',
    regimenField: 'DRUG_NAME',
    tagField: 'TAG'
  }
};

function isNumeric(val) {
  if (val === null || val === undefined || val === '') return false;
  const str = String(val).trim().toLowerCase();
  const invalid = ['true','false','yes','no','é˜³æ€§','é˜´æ€§','normal','abnormal','n/a','na','-','--','none','null','undefined'];
  if (invalid.includes(str)) return false;
  return !isNaN(val) && !isNaN(parseFloat(val));
}

function readFile(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = e => resolve(e.target.result);
    reader.onerror = reject;
    reader.readAsText(file);
  });
}

document.getElementById('dataFile').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  document.getElementById('dataFileName').textContent = `å·²åŠ è½½: ${file.name}`;
  const text = await readFile(file);
  const data = Papa.parse(text, { header: true, skipEmptyLines: true }).data;
  processMainData(data);
  tryRenderContent();
  document.getElementById('dataFileName').textContent = `å·²åŠ è½½: ${file.name}ï¼Œå…± ${data.length} æ¡æ•°æ®`;
  e.target.value = '';
});

document.getElementById('medFile').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  document.getElementById('medFileName').textContent = `å·²åŠ è½½: ${file.name}`;
  const text = await readFile(file);
  const meds = Papa.parse(text, { header: true, skipEmptyLines: true }).data;
  processMedications(meds);
  tryRenderContent();
  document.getElementById('medFileName').textContent = `å·²åŠ è½½: ${file.name}ï¼Œå…± ${meds.length} æ¡æ•°æ®`;
  e.target.value = '';
});

function processMainData(rows) {
  allIndicators = [];
  const { timeField, nameField, valueField } = DEFAULT_CONFIG.dataTable;

  for (const row of rows) {
    const rawTime = row[timeField]?.trim();
    const name = row[nameField]?.trim();
    const val = row[valueField];

    if (!rawTime || !name) continue;

    const dt = new Date(rawTime);
    if (isNaN(dt)) continue;
    const testTime = dt.toISOString().split('T')[0];

    if (isNumeric(val)) {
      allIndicators.push({
        indicatorName: name,
        indicatorValue: parseFloat(val),
        indicatorValueRaw: val,
        testTime: testTime
      });
    }
  }

  uniqueNames = [...new Set(allIndicators.map(i => i.indicatorName))].sort();
}

function processMedications(rows) {
  medications = [];
  const { startTimeField, endTimeField, regimenField,tagField } = DEFAULT_CONFIG.medicationTable;

  for (const row of rows) {
    const start = row[startTimeField]?.trim();
    const end = row[endTimeField]?.trim();
    const regimen = row[regimenField]?.trim();
    const tag = row[tagField]?.trim();
    if (!start || !end || !regimen) continue;

    const startDt = new Date(start);
    const endDt = new Date(end);
    if (isNaN(startDt) || isNaN(endDt) || startDt > endDt) continue;

    medications.push({
      startTime: startDt.toISOString().split('T')[0],
      endTime: endDt.toISOString().split('T')[0],
      regimen: regimen,
      tag: tag,
      startTimeStamp: startDt.getTime(),
      endTimeStamp: endDt.getTime()
    });
  }
}

function tryRenderContent() {
  if (allIndicators.length > 0) {
    renderSelector();
    document.getElementById('content').classList.remove('hidden');
    setTimeout(() => renderCharts(), 10);
  }
}

function renderSelector() {
  const container = document.getElementById('checkboxContainer');
  container.innerHTML = '';
  uniqueNames.forEach(name => {
    const label = document.createElement('label');
    label.className = 'checkbox-item';
    // ğŸ‘‡ å…³é”®ï¼šæ·»åŠ  data-indicator-name å±æ€§ç”¨äºæœç´¢
    label.setAttribute('data-indicator-name', name);
    label.innerHTML = `<input type="checkbox" value="${name}"> ${name}`;
    container.appendChild(label);
  });

  const firstCheckbox = container.querySelector('input[type="checkbox"]');
  if (firstCheckbox) firstCheckbox.checked = true;
}

function getMedicationsAtTime(timeStamp) {
  if (medications.length === 0) return ['æ— ç”¨è¯è®°å½•'];
  const matchedMeds = medications.filter(med => timeStamp >= med.startTimeStamp && timeStamp <= med.endTimeStamp);
  if (matchedMeds.length === 0) return ['æ— ç”¨è¯è®°å½•'];
  return matchedMeds.map(med => `${med.regimen} (${med.startTime} è‡³ ${med.endTime})`);
}

// ========== å›¾è¡¨æ¸²æŸ“ ==========
function renderCharts() {
  const selected = Array.from(document.querySelectorAll('#checkboxContainer input:checked')).map(cb => cb.value);
  if (selected.length === 0) {
    alert('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªæŒ‡æ ‡');
    return;
  }

  const chartDom = document.getElementById('chartContainer');
  const timelineDom = document.getElementById('timelineContainer');
  const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);
  const timeline = echarts.getInstanceByDom(timelineDom) || echarts.init(timelineDom);

  const indicatorData = allIndicators.filter(i => selected.includes(i.indicatorName));

  const allTimePoints = [
    ...indicatorData.map(d => new Date(d.testTime).getTime()),
    ...medications.flatMap(m => [new Date(m.startTime).getTime(), new Date(m.endTime).getTime()])
  ];

  let globalMin, globalMax;
  if (allTimePoints.length > 0) {
    globalMin = Math.min(...allTimePoints);
    globalMax = Math.max(...allTimePoints);
    const range = globalMax - globalMin;
    const padding = range * 0.05 || 24 * 60 * 60 * 1000;
    globalMin -= padding;
    globalMax += padding;
  } else {
    const now = Date.now();
    globalMin = now - 30 * 24 * 3600 * 1000;
    globalMax = now;
  }

  const seriesMap = new Map();
  selected.forEach(name => seriesMap.set(name, []));
  indicatorData.forEach(d => {
    if (seriesMap.has(d.indicatorName)) {
      seriesMap.get(d.indicatorName).push([
        new Date(d.testTime).getTime(),
        d.indicatorValue,
        d.indicatorValueRaw
      ]);
    }
  });

  const colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f'];

  const showKeyPoints = document.getElementById('showKeyPoints').checked;
  const showChangeRate = document.getElementById('showChangeRate').checked;
  const changeThreshold = parseFloat(document.getElementById('changeThreshold').value) || 0;
  const percentThreshold = parseFloat(document.getElementById('percentThreshold').value) || 0;
  document.getElementById('percentValue').textContent = `${Math.round(percentThreshold)}%`;

  const series = selected.map((name, idx) => {
    const data = seriesMap.get(name).sort((a, b) => a[0] - b[0]);
    const color = colors[idx % colors.length];
    const markPointData = [];

    if (showKeyPoints && data.length > 0) {
      const values = data.map(d => d[1]);
      const minVal = Math.min(...values);
      const maxVal = Math.max(...values);
      const lastPoint = data[data.length - 1];

      data.forEach(p => {
        const [time, val, rawVal] = p;
        const isLast = (time === lastPoint[0]);

        if (val === minVal || val === maxVal) {
          markPointData.push({
            coord: [time, val],
            label: {
              show: true,
              formatter: rawVal,
              color: '#000',
              fontSize: 12,
              offset: [0, -10],
              fontWeight: 'bold'
            },
            itemStyle: { color: color },
            symbolSize: 5,
            tooltip: { show: true }
          });
        }

        if (isLast) {
          markPointData.push({
            coord: [time, val],
            label: {
              show: true,
              formatter: `${name}\n${rawVal}`,
              color: '#000',
              fontSize: 12,
              fontWeight: 'bold',
              backgroundColor: 'rgba(255,255,255,0.8)',
              borderColor: '#ccc',
              borderRadius: 4,
              offset: [0, -20],
              padding: [4, 6]
            },
            itemStyle: { color: color },
            symbolSize: 5,
            tooltip: { show: true }
          });
        }
      });
    }

    if (showChangeRate && data.length >= 2) {
      for (let i = 1; i < data.length; i++) {
        const prev = data[i - 1];
        const curr = data[i];
        const diff = curr[1] - prev[1];
        const absDiff = Math.abs(diff);
        const percent = prev[1] !== 0 ? (diff / prev[1]) * 100 : 0;

        if (absDiff >= changeThreshold && Math.abs(percent) >= percentThreshold) {
          const sign = diff > 0 ? '+' : '-';
          const fmtDiff = diff.toFixed(1);
          const fmtPercent = Math.abs(percent).toFixed(1);
          const label = `${sign}${fmtDiff} (${sign}${fmtPercent}%)`;
          markPointData.push({
            coord: [curr[0], curr[1]],
            label: {
              show: true,
              formatter: `{a|${label}}`,
              offset: diff > 0 ? [0, -20] : [0, 20],
              rich: { a: { fontSize: 12, color: diff > 0 ? '#FF6B6B' : '#4ECDC4', fontWeight: 'bold' } }
            },
            itemStyle: { color: color },
            symbolSize: 4,
            tooltip: { show: true }
          });
        }
      }
    }

    const drawData = data.map(item => [item[0], item[1]]);

    return {
      name,
      type: 'line',
      data: drawData,
      smooth: false,
      symbolSize: 5,
      lineStyle: { width: 2 },
      itemStyle: { color: color },
      markPoint: {
        data: markPointData
      }
    };
  });

  chart.setOption({
    title: { text: 'æŒ‡æ ‡è¶‹åŠ¿å›¾', left: 'center', textStyle: { fontSize: 16 } },
    tooltip: {
      trigger: 'axis',
      formatter: function(params) {
        const time = new Date(params[0].axisValue);
        const timeStr = time.toISOString().split('T')[0];
        const timeStamp = time.getTime();
        const medInfo = getMedicationsAtTime(timeStamp);
        let tooltipHtml = `<div style="font-size:12px;"><strong>æ—¶é—´ï¼š</strong>${timeStr}</div>`;
        params.forEach(param => {
          if (param.value !== null && param.value !== undefined) {
            let rawVal = param.value.toString();
            const seriesData = seriesMap.get(param.seriesName) || [];
            const findItem = seriesData.find(item => item[0] === param.axisValue);
            if (findItem) rawVal = findItem[2];
            tooltipHtml += `<div style="font-size:12px;"><strong>${param.seriesName}ï¼š</strong>${rawVal}</div>`;
          }
        });
        tooltipHtml += '<div style="font-size:12px;margin-top:4px;"><strong>ç”¨è¯ï¼š</strong></div>';
        medInfo.forEach(med => {
          tooltipHtml += `<div style="font-size:11px; padding-left:8px;">â€¢ ${med}</div>`;
        });
        return tooltipHtml;
      },
      backgroundColor: 'rgba(255,255,255,0.95)',
      borderColor: '#ddd',
      borderWidth: 1,
      padding: 10,
      textStyle: { fontSize: 12 }
    },
    legend: { data: selected, top: 28, itemHeight: 10, itemWidth: 10 },
    xAxis: {
      type: 'time',
      min: globalMin,
      max: globalMax
    },
    yAxis: { type: 'value' },
    series,
    grid: { top: 60, bottom: 50, left: 60, right: 40 },
    dataZoom: [
      { type: 'slider', xAxisIndex: 0, height: 20, bottom: 20, fillerColor: 'rgba(60, 180, 255, 0.15)' },
      { type: 'inside', xAxisIndex: 0, zoomOnMouseWheel: true, moveOnMouseMove: true }
    ]
  }, true);

  renderTimeline(timeline, medications, indicatorData, globalMin, globalMax);
}

function renderTimeline(timeline, meds, indicators, globalMin, globalMax) {
  timeline.clear();

  const baseOption = {
    title: {
      text: meds.length ? 'ç”¨è¯æ—¶é—´è½´' : 'æ— ç”¨è¯æ•°æ®',
      left: 'center',
      textStyle: { fontSize: 14 }
    },
    xAxis: {
      type: 'time',
      min: globalMin,
      max: globalMax,
      axisLabel: { formatter: '{yyyy}-{MM}' }
    },
    yAxis: { type: 'value', show: false, min: 0, max: 1 },
    grid: { top: 5, bottom: 20, left: 10, right: 10 },
    tooltip: {
      show: true,
      trigger: 'item',
      formatter: (params) => {
        if (params.data && params.data._med) {
          const med = params.data._med;
          return `<strong>${med.regimen}</strong><br/>${med.startTime} è‡³ ${med.endTime}`;
        }
        return '';
      }
    }
  };

  if (meds.length === 0) {
    timeline.setOption(baseOption);
    document.getElementById('legendContainer').innerHTML = '<p style="font-size:0.875rem;color:#6b7280;">æš‚æ— ç”¨è¯è®°å½•</p>';
    return;
  }

  const regimens = [...new Set(meds.map(m => m.regimen))];
  const colors = ['#FF6B6B', '#FFD93D', '#4ECDC4', '#45B7D1', '#96CEB4', '#DDA0DD', '#FFB347', '#8BC34A'];
  const colorMap = {};
  regimens.forEach((r, i) => colorMap[r] = colors[i % colors.length]);

  const series = regimens.map(regimen => {
    const items = meds.filter(m => m.regimen === regimen);
    const data = [];
    const markPoints = [];

    items.forEach(m => {
      const start = new Date(m.startTime).getTime();
      const end = new Date(m.endTime).getTime();
      data.push([start, 0.5], [end, 0.5], [end, null]);

        // è®¡ç®—æŒç»­æ—¶é—´æ–‡æœ¬
        const startDate = new Date(m.startTime);
        const endDate = new Date(m.endTime);
        let diffTime = endDate - startDate;
        let diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)); // å¤©æ•°ä»ä¿ç•™åŸæœ‰çš„å‘ä¸Šå–æ•´é€»è¾‘
        let durationText;

        if (diffDays >= 30) {
          // 1. æœˆä»½æ”¹ç”¨ Math.floor å‘ä¸‹å–æ•´ï¼Œé¿å…ä¸è¶³1ä¸ªæœˆè¢«è¯¯ç®—ä¸º1ä¸ªæœˆ
          const diffMonths = Math.floor(diffDays / 30);
          // 2. å‰©ä½™å¤©æ•°ç”¨å‡æ³•è®¡ç®—ï¼Œæ¯”å–ä½™æ›´ç›´è§‚ç²¾å‡†ï¼Œé¿å…æç«¯åœºæ™¯åå·®
          const remainingDays = diffDays - diffMonths * 30;
          // 3. ä¼˜åŒ–æ–‡æœ¬å±•ç¤ºï¼Œé¿å…å‡ºç°â€œXä¸ªæœˆ0å¤©â€çš„å†—ä½™è¡¨è¿°
          durationText = remainingDays > 0
            ? `${diffMonths}ä¸ªæœˆ${remainingDays}å¤©`
            : `${diffMonths}ä¸ªæœˆ`;
        } else {
          durationText = `${diffDays}å¤©`;
        }

      const tagOrRegimen = m.tag || m.regimen || 'æœªçŸ¥';

      let fullText = `${tagOrRegimen}\n\n(${durationText})`;

      fullText = `${fullText}\n${m.startTime.slice(2)} åˆ° ${m.endTime.slice(2)}`;

      // âœ… å…³é”®ä¿®å¤ï¼šæ·»åŠ  _med å­—æ®µ
      const midTime = (start + end) / 2; // ç§»é™¤ -20
      markPoints.push({
        name: regimen,
        coord: [midTime, 0.5],
        value: fullText,
        _med: m, // ğŸ‘ˆ å¿…é¡»åŠ è¿™ä¸€è¡Œï¼
        label: {
          show: true,
          position: 'middle',
          align: 'center',
          formatter: '{c}',
          fontSize: 12,
          padding: [12, 6],
          fontWeight: 'bold',
          color: '#FFFFFF',
          width: 'auto',
          overflow: 'none'
        },
        symbol: 'circle',
        symbolSize: 1,
        itemStyle: {
          color: 'transparent'
        },
        z: 999
      });
    });

    return {
      name: regimen,
      type: 'line',
      symbol: 'none',
      lineStyle: { width: 0 },
      areaStyle: {
        color: colorMap[regimen],
        opacity: 0.7
      },
      data: data,
      markPoint: {
        data: markPoints,
        tooltip: { show: true } // âœ… æ˜¾å¼å¼€å¯
      }
    };
  });

  timeline.setOption({
    ...baseOption,
    series: series
  });

  const legend = document.getElementById('legendContainer');
  legend.innerHTML = '';
  regimens.forEach(r => {
    const div = document.createElement('div');
    div.className = 'legend-item';
    div.innerHTML = `<div class="legend-color" style="background:${colorMap[r]}"></div> ${r}`;
    legend.appendChild(div);
  });
}

document.addEventListener('DOMContentLoaded', () => {
  const showChangeRate = document.getElementById('showChangeRate');
  const changeThresholdContainer = document.getElementById('changeThresholdContainer');
  const percentThresholdContainer = document.getElementById('percentThresholdContainer');

  showChangeRate.addEventListener('change', function () {
    if (this.checked) {
      changeThresholdContainer.style.display = 'block';
      percentThresholdContainer.style.display = 'block';
    } else {
      changeThresholdContainer.style.display = 'none';
      percentThresholdContainer.style.display = 'none';
    }
  });

  document.getElementById('showKeyPoints').addEventListener('change', () => renderCharts());
  showChangeRate.addEventListener('change', () => renderCharts());
  document.getElementById('changeThreshold').addEventListener('input', () => renderCharts());
  document.getElementById('percentThreshold').addEventListener('input', () => renderCharts());

  changeThresholdContainer.style.display = 'none';
  percentThresholdContainer.style.display = 'none';
});
</script>
<script>
function filterIndicators() {
  const searchKeyword = document.getElementById('indicatorSearchInput').value.trim().toLowerCase();
  const allIndicatorItems = document.querySelectorAll('#checkboxContainer .checkbox-item');

  allIndicatorItems.forEach(item => {
    const indicatorName = item.getAttribute('data-indicator-name').toLowerCase();
    if (searchKeyword === '' || indicatorName.includes(searchKeyword)) {
      item.style.display = ''; // æ¢å¤é»˜è®¤æ˜¾ç¤ºï¼ˆé¿å…å†…è” display: none æ®‹ç•™ï¼‰
    } else {
      item.style.display = 'none';
    }
  });
}
</script>
</body>
</html>